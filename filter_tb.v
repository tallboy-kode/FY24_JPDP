// -------------------------------------------------------------
//
// Module: filter_tb
// Generated by MATLAB(R) 9.14 and Filter Design HDL Coder 3.1.13.
// Generated on: 2024-01-26 09:39:05
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetDirectory: /home/kristopher.small/Documents/MATLAB
// Name: mk84_FIR_B
// TargetLanguage: Verilog
// TestBenchStimulus: impulse step ramp chirp noise 
//
// Filter Settings:
//
// Discrete-Time FIR Filter (real)
// -------------------------------
// Filter Structure  : Direct-Form FIR
// Filter Length     : 35
// Stable            : Yes
// Linear Phase      : Yes (Type 1)
// -------------------------------------------------------------
`timescale 1 ns / 1 ns 

module filter_tb;

// -------------------------------------------------------------
// filter_in_data_log_task
// -------------------------------------------------------------
  task filter_in_data_log_task; 
    input          clk;
    input          reset;
    input          rdenb;
    inout  [11:0]  addr;
    output         done;
  begin

    // Counter to generate the address
    if (reset == 1) begin 
        addr = 0;
    end
    else begin
      if (rdenb == 1) begin
        if (addr == 3316) begin 
            $fclose(fp_dataIn);
            addr = addr; 
        end
        else
          addr =  addr + 1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
    else if (addr == 3316) begin
      done = 1;
    end
    else
      done = 0; 

  end
  endtask // filter_in_data_log_task


// -------------------------------------------------------------
// filter_out_task
// -------------------------------------------------------------
  task filter_out_task; 
    input          clk;
    input          reset;
    input          rdenb;
    inout  [11:0]  addr;
    output         done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 3316) begin
          $fclose(fp_dataOut);
          addr = addr; 
        end
        else
          addr = #1  addr + 1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
    else if (addr == 3316)
      done = 1; 
    else
      done = 0; 

  end
  endtask // filter_out_task

 // Constants
 parameter clk_high                         = 5;
 parameter clk_low                          = 5;
 parameter clk_period                       = 10;
 parameter clk_hold                         = 2;
// -------------------------------------------------------------
//
// Module: filter_tb_data
// Generated by MATLAB(R) 9.14 and Filter Design HDL Coder 3.1.13.
// Generated on: 2024-01-26 09:39:06
// -------------------------------------------------------------

 integer f,i, g, d;
 integer fp_dataOut;
 integer fp_dataIn;
 real din_temp;  //double
 
 // **************************************
 initial //Input & Output data
 begin
    
    //Uncomment the desired input file below to run through the filter. Only select one at a time.
    
	//fp_dataIn = $fopen("C:/dev_nonrepo/project_fir_ksmall/input_data_noise.txt", "r");
	fp_dataIn = $fopen("C:/dev_nonrepo/project_fir_ksmall/input_data_impulse.txt", "r");
	//fp_dataIn = $fopen("C:/dev_nonrepo/project_fir_ksmall/input_data_sine.txt", "r");
	
	fp_dataOut = $fopen("C:/dev_nonrepo/project_fir_ksmall/output_data.txt", "w");


 end // Input & Output data
//************************************

// -------------------------------------------------------------
// abs_real()
// -------------------------------------------------------------
function real abs_real;
input real ip_val;
// return value = |ip_val|
 begin
 abs_real = (ip_val > 0) ? ip_val : -ip_val;
 end
endfunction //function abs_real

 // Signals
  reg  clk; // boolean
  reg  clk_enable; // boolean
  reg  reset; // boolean
  reg  [63:0] filter_in; // double
  wire [63:0] filter_out; // double

  reg  tb_enb; // boolean
  wire srcDone; // boolean
  wire snkDone; // boolean
  wire testFailure; // boolean
  reg  tbenb_dly; // boolean
  reg  rdEnb; // boolean
  wire filter_in_data_log_rdenb; // boolean
  reg  [11:0] filter_in_data_log_addr; // ufix12
  reg  filter_in_data_log_done; // boolean
  wire [63:0] rawData_filter_in; // double
   reg  filter_out_testFailure; // boolean
  integer filter_out_errCnt; // uint32
  wire delayLine_out; // boolean
  wire expected_ce_out; // boolean
  reg  int_delay_pipe [0:1] ; // boolean
  wire filter_out_rdenb; // boolean
  reg  [11:0] filter_out_addr; // ufix12
  reg  filter_out_done; // boolean
  reg  check1_Done; // boolean
  
  
 // Module Instances - THIS IS THE DEVICE UNDER TEST (DUT)
  mk84_FIR_B u_mk84_FIR_B
    (
    .clk(clk),
    .clk_enable(clk_enable),
    .reset(reset),
    .filter_in(filter_in),
    .filter_out(filter_out)
    );

 // Block Statements
  // -------------------------------------------------------------
  // Driving the test bench enable
  // -------------------------------------------------------------

  always @(reset, snkDone)
  begin
    if (reset == 1'b1)
      tb_enb <= 1'b0;
    else if (snkDone == 1'b0 )
      tb_enb <= 1'b1;
    else begin
    # (clk_period * 2);
      tb_enb <= 1'b0;
    end
  end
  
 

  // -------------------------------------------------------------
  // System Clock (fast clock) and reset
  // -------------------------------------------------------------

  always  // clock generation
  begin // clk_gen
    clk <= 1'b1;
    # clk_high;
    clk <= 1'b0;
    # clk_low;
    if (snkDone == 1) begin
      clk <= 1'b1;
      # clk_high;
      clk <= 1'b0;
      # clk_low;
      $stop;
    end
  end  // clk_gen

//  end

  initial  // reset block
  begin // reset_gen
    reset <= 1'b1;
    # (clk_period * 2);
    @ (posedge clk);
    # (clk_hold);
    reset <= 1'b0;
  end  // reset_gen

  // -------------------------------------------------------------
  // Testbench clock enable
  // -------------------------------------------------------------

  always @ (posedge clk or posedge reset)
    begin: tb_enb_delay
      if (reset == 1'b1) begin
        tbenb_dly <= 1'b0;
      end
      else begin
        if (tb_enb == 1'b1) begin
          tbenb_dly <= tb_enb;
        end
      end
    end // tb_enb_delay

  always @(snkDone, tbenb_dly)
  begin
    if (snkDone == 0)
      rdEnb <= tbenb_dly;
    else
      rdEnb <= 0;
  end

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    filter_in_data_log_task(clk,reset,
                            filter_in_data_log_rdenb,filter_in_data_log_addr,
                            filter_in_data_log_done);
  end

  assign filter_in_data_log_rdenb = rdEnb;
   
  always @ (filter_in_data_log_rdenb, filter_in_data_log_addr)
  begin // Read an sample from the data input file
    if (filter_in_data_log_rdenb == 1) begin
      $fscanf(fp_dataIn, "%f", din_temp);
      filter_in <= # clk_hold $realtobits(din_temp);
    end
  end // Read an sample from the data input file

  // -------------------------------------------------------------
  // Create done signal for Input data
  // -------------------------------------------------------------

  assign srcDone = filter_in_data_log_done;


  always @( posedge clk or posedge reset)
    begin: ceout_delayLine
      if (reset == 1'b1) begin
        int_delay_pipe[0] <= 1'b0;
        int_delay_pipe[1] <= 1'b0;
      end
      else begin
        if (clk_enable == 1'b1) begin
        int_delay_pipe[0] <= rdEnb;
        int_delay_pipe[1] <= int_delay_pipe[0];
        end
      end
    end // ceout_delayLine

  assign delayLine_out = int_delay_pipe[1];

  assign expected_ce_out =  delayLine_out & clk_enable;

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    filter_out_task(clk,reset,
                    filter_out_rdenb,filter_out_addr,
                    filter_out_done);
  end

  assign filter_out_rdenb = expected_ce_out;

  always @ (posedge clk or posedge reset) // checker_filter_out
  begin
    if (reset == 1) begin
      filter_out_testFailure <= 0;
      filter_out_errCnt <= 0;
    end 
    else begin 
      if (filter_out_rdenb == 1 ) begin 
         $fwrite(fp_dataOut, "%f\n", $bitstoreal(filter_out));
      end
    end
  end // checker_filter_out

  always @ (posedge clk or posedge reset) // checkDone_1
  begin
    if (reset == 1) begin
      check1_Done <= 0;
    end
    else if ((check1_Done == 0) && (filter_out_done == 1) && (filter_out_rdenb == 1)) begin
         check1_Done <= 1;
    end
  end


  // -------------------------------------------------------------
  // Create done and test failure signal for output data
  // -------------------------------------------------------------

  assign snkDone = check1_Done;

  assign testFailure = filter_out_testFailure;

  // -------------------------------------------------------------
  // Global clock enable
  // -------------------------------------------------------------
  always @(snkDone, tbenb_dly)
  begin
    if (snkDone == 0)
      # clk_hold clk_enable <= tbenb_dly;
    else
      # clk_hold clk_enable <= 0;
  end
  
 // Assignment Statements

endmodule // filter_tb
